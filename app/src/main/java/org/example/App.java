/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import lombok.extern.slf4j.Slf4j;
import org.example.exception.ApiException;
import org.example.model.User;
import org.example.model.UserSummary;
import org.example.service.ApiService;
import org.example.service.ApiServiceImpl;
import org.example.service.UserTransformationService;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

/**
 * Main application class that demonstrates fetching data from an API,
 * transforming it, and posting the transformed data.
 * Optimized for high throughput (10k TPS).
 */
@Slf4j
public class App {
    private final ApiService apiService;
    private final ApiServiceImpl apiServiceImpl; // For async methods
    private final UserTransformationService transformationService;
    private final ExecutorService executorService;

    // Number of threads for parallel processing
    private static final int THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors() * 2;
    
    // Batch size for processing
    private static final int BATCH_SIZE = 100;

    /**
     * Constructor with default services.
     */
    public App() {
        this(new ApiServiceImpl(), new UserTransformationService());
        log.debug("App initialized with default services");
    }

    /**
     * Constructor with custom services for dependency injection.
     *
     * @param apiService the API service to use
     * @param transformationService the transformation service to use
     */
    public App(ApiService apiService, UserTransformationService transformationService) {
        this.apiService = apiService;
        this.transformationService = transformationService;
        
        // Cast to ApiServiceImpl if possible for async methods
        if (apiService instanceof ApiServiceImpl) {
            this.apiServiceImpl = (ApiServiceImpl) apiService;
        } else {
            this.apiServiceImpl = null;
            log.warn("ApiService is not an instance of ApiServiceImpl, async methods will not be available");
        }
        
        // Create a thread pool for parallel processing
        this.executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);
        log.info("App initialized with thread pool size: {}", THREAD_POOL_SIZE);
        
        log.debug("App initialized with custom services");
    }

    /**
     * Fetches users from the API.
     *
     * @return a list of users
     * @throws IOException if an I/O error occurs
     */
    public List<User> fetchUsers() throws IOException {
        try {
            log.info("Fetching users from API");
            List<User> users = apiService.fetchUsers();
            log.info("Successfully fetched {} users from API", users.size());
            return users;
        } catch (IOException e) {
            log.error("Failed to fetch users from API", e);
            throw e;
        } catch (Exception e) {
            log.error("Unexpected error when fetching users from API", e);
            throw new ApiException("Failed to fetch users", 500, "/users", e);
        }
    }
    
    /**
     * Fetches users from the API asynchronously.
     *
     * @return a CompletableFuture containing a list of users
     */
    public CompletableFuture<List<User>> fetchUsersAsync() {
        if (apiServiceImpl == null) {
            log.warn("ApiServiceImpl not available, falling back to synchronous method");
            return CompletableFuture.supplyAsync(() -> {
                try {
                    return fetchUsers();
                } catch (IOException e) {
                    throw new CompletionException(e);
                }
            }, executorService);
        }
        
        log.info("Fetching users from API asynchronously");
        return apiServiceImpl.fetchUsersAsync();
    }

    /**
     * Transforms users into user summaries.
     *
     * @param users the users to transform
     * @return a list of user summaries
     */
    public List<UserSummary> transformUsers(List<User> users) {
        if (users == null) {
            log.warn("Attempted to transform null user list, returning empty list");
            return Collections.emptyList();
        }
        
        log.info("Transforming {} users into summaries", users.size());
        List<UserSummary> summaries = transformationService.transformUsers(users);
        log.info("Successfully transformed {} users into summaries", summaries.size());
        return summaries;
    }
    
    /**
     * Transforms users into user summaries in parallel for high throughput.
     *
     * @param users the users to transform
     * @return a list of user summaries
     */
    public List<UserSummary> transformUsersParallel(List<User> users) {
        if (users == null) {
            log.warn("Attempted to transform null user list, returning empty list");
            return Collections.emptyList();
        }
        
        log.info("Transforming {} users into summaries in parallel", users.size());
        
        // Process in batches for better performance
        List<List<User>> batches = new ArrayList<>();
        for (int i = 0; i < users.size(); i += BATCH_SIZE) {
            batches.add(users.subList(i, Math.min(i + BATCH_SIZE, users.size())));
        }
        
        // Process each batch in parallel
        List<UserSummary> result = batches.parallelStream()
                .map(transformationService::transformUsers)
                .flatMap(List::stream)
                .collect(Collectors.toList());
        
        log.info("Successfully transformed {} users into summaries in parallel", result.size());
        return result;
    }

    /**
     * Filters users by email domain and transforms them into user summaries.
     *
     * @param users the users to filter and transform
     * @param domain the email domain to filter by
     * @return a list of filtered and transformed user summaries
     */
    public List<UserSummary> filterByEmailDomainAndTransform(List<User> users, String domain) {
        if (users == null) {
            log.warn("Attempted to filter null user list, returning empty list");
            return Collections.emptyList();
        }
        
        if (domain == null || domain.isEmpty()) {
            log.warn("Attempted to filter by null or empty domain, returning all users");
            return transformUsers(users);
        }
        
        log.info("Filtering {} users by email domain: {}", users.size(), domain);
        List<UserSummary> summaries = transformationService.filterByEmailDomainAndTransform(users, domain);
        log.info("Successfully filtered and transformed {} users with email domain: {}", 
                summaries.size(), domain);
        return summaries;
    }
    
    /**
     * Filters users by email domain and transforms them into user summaries in parallel.
     *
     * @param users the users to filter and transform
     * @param domain the email domain to filter by
     * @return a list of filtered and transformed user summaries
     */
    public List<UserSummary> filterByEmailDomainAndTransformParallel(List<User> users, String domain) {
        if (users == null) {
            log.warn("Attempted to filter null user list, returning empty list");
            return Collections.emptyList();
        }
        
        if (domain == null || domain.isEmpty()) {
            log.warn("Attempted to filter by null or empty domain, returning all users");
            return transformUsersParallel(users);
        }
        
        log.info("Filtering {} users by email domain: {} in parallel", users.size(), domain);
        
        // Process in batches for better performance
        List<List<User>> batches = new ArrayList<>();
        for (int i = 0; i < users.size(); i += BATCH_SIZE) {
            batches.add(users.subList(i, Math.min(i + BATCH_SIZE, users.size())));
        }
        
        // Process each batch in parallel
        List<UserSummary> result = batches.parallelStream()
                .map(batch -> transformationService.filterByEmailDomainAndTransform(batch, domain))
                .flatMap(List::stream)
                .collect(Collectors.toList());
        
        log.info("Successfully filtered and transformed {} users with email domain: {} in parallel", 
                result.size(), domain);
        return result;
    }

    /**
     * Posts a user summary to the API.
     *
     * @param userSummary the user summary to post
     * @return true if the post was successful, false otherwise
     * @throws IOException if an I/O error occurs
     */
    public boolean postUserSummary(UserSummary userSummary) throws IOException {
        if (userSummary == null) {
            log.warn("Attempted to post null user summary, returning false");
            return false;
        }
        
        try {
            log.info("Posting user summary for user: {}", userSummary.getFullName());
            boolean success = apiService.postUserSummary(userSummary);
            log.info("Successfully posted user summary for user: {}, result: {}", 
                    userSummary.getFullName(), success);
            return success;
        } catch (IOException e) {
            log.error("Failed to post user summary for user: {}", userSummary.getFullName(), e);
            throw e;
        } catch (Exception e) {
            log.error("Unexpected error when posting user summary for user: {}", 
                    userSummary.getFullName(), e);
            throw new ApiException("Failed to post user summary", 500, "/posts", e);
        }
    }
    
    /**
     * Posts a user summary to the API asynchronously.
     *
     * @param userSummary the user summary to post
     * @return a CompletableFuture containing the result of the operation
     */
    public CompletableFuture<Boolean> postUserSummaryAsync(UserSummary userSummary) {
        if (userSummary == null) {
            log.warn("Attempted to post null user summary asynchronously, returning false");
            return CompletableFuture.completedFuture(false);
        }
        
        if (apiServiceImpl == null) {
            log.warn("ApiServiceImpl not available, falling back to synchronous method");
            return CompletableFuture.supplyAsync(() -> {
                try {
                    return postUserSummary(userSummary);
                } catch (IOException e) {
                    throw new CompletionException(e);
                }
            }, executorService);
        }
        
        log.info("Posting user summary for user: {} asynchronously", userSummary.getFullName());
        return apiServiceImpl.postUserSummaryAsync(userSummary);
    }
    
    /**
     * Posts multiple user summaries to the API in parallel.
     *
     * @param summaries the list of user summaries to post
     * @return a list of results indicating success or failure for each summary
     */
    public List<Boolean> postUserSummariesParallel(List<UserSummary> summaries) {
        if (summaries == null || summaries.isEmpty()) {
            log.warn("Attempted to post null or empty user summaries list, returning empty list");
            return Collections.emptyList();
        }
        
        log.info("Posting {} user summaries in parallel", summaries.size());
        
        List<CompletableFuture<Boolean>> futures = summaries.stream()
                .map(this::postUserSummaryAsync)
                .collect(Collectors.toList());
        
        // Wait for all futures to complete
        CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                futures.toArray(new CompletableFuture[0]));
        
        // Get results
        List<Boolean> results = allFutures.thenApply(v -> 
                futures.stream()
                        .map(CompletableFuture::join)
                        .collect(Collectors.toList())
        ).join();
        
        long successCount = results.stream().filter(Boolean::booleanValue).count();
        log.info("Successfully posted {}/{} user summaries in parallel", successCount, summaries.size());
        
        return results;
    }

    /**
     * Demonstrates the complete workflow: fetch, transform, and post.
     * Optimized for high throughput with async and parallel processing.
     *
     * @param args command line arguments
     */
    public static void main(String[] args) {
        log.info("Starting application");
        App app = new App();
        
        try {
            // Fetch users from API asynchronously
            CompletableFuture<List<User>> usersFuture = app.fetchUsersAsync();
            
            // Wait for users to be fetched
            List<User> users = usersFuture.join();
            log.info("Fetched {} users from API", users.size());
            
            // Filter users by email domain and transform in parallel
            String emailDomain = "example.com";
            List<UserSummary> filteredSummaries = app.filterByEmailDomainAndTransformParallel(users, emailDomain);
            log.info("Filtered and transformed {} users with email domain: {}", 
                    filteredSummaries.size(), emailDomain);
            
            if (filteredSummaries.isEmpty()) {
                log.warn("No users found with email domain: {}, trying with city filter", emailDomain);
                // Try filtering by city instead
                String city = "Gwenborough";
                filteredSummaries = app.transformationService.filterByCityAndTransform(users, city);
                log.info("Filtered and transformed {} users from city: {}", 
                        filteredSummaries.size(), city);
            }
            
            // Post all user summaries in parallel
            List<Boolean> results = app.postUserSummariesParallel(filteredSummaries);
            
            // Log results
            for (int i = 0; i < filteredSummaries.size(); i++) {
                UserSummary summary = filteredSummaries.get(i);
                boolean success = results.get(i);
                log.info("Posted user summary for {} ({}): {}", 
                        summary.getFullName(), summary.getUserId(), 
                        (success ? "SUCCESS" : "FAILED"));
            }
            
            long successCount = results.stream().filter(Boolean::booleanValue).count();
            log.info("Successfully posted {}/{} user summaries", 
                    successCount, filteredSummaries.size());
            
            // Shutdown executor service
            app.executorService.shutdown();
            if (!app.executorService.awaitTermination(30, TimeUnit.SECONDS)) {
                app.executorService.shutdownNow();
            }
            
            // Shutdown ApiServiceImpl if available
            if (app.apiServiceImpl != null) {
                app.apiServiceImpl.shutdown();
            }
            
            log.info("Application completed successfully");
            
        } catch (Exception e) {
            log.error("Error during application execution: {}", e.getMessage(), e);
            System.err.println("Error during application execution: " + e.getMessage());
        }
    }
}
